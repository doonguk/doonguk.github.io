{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/함수형-프로그래밍(엄격vs느긋)-(1)/","result":{"data":{"site":{"siteMetadata":{"title":"Study Log","author":"[HongDongUk]","siteUrl":"https://donguk.netlify.com","comment":{"disqusShortName":"","utterances":"doonguk/doonguk.github.io"},"sponsor":{"buyMeACoffeeId":"doonguk"}}},"markdownRemark":{"id":"41c2eece-3443-52cf-87f5-2b629371aaa7","excerpt":"연속된 제너레이터의 계산 순서를 알아보기 전에 map 함수와 filter 함수도 제너레이터를 이용하여 구현해보자. L.map 기존 map함수와 다른 점은  위와 같이 이터레이터를 생성한 것 만으로는 내가 원하는 값을 구할 수 없고 next() 함수를 호출 한 만큼의 값만 얻을 수 있다. 따라서 array를 직접 생성하지 않기 때문에 내가 원하는 대로 평가가 가능하다 스프레드 연산자로 next() 함수를 호출하여 평가할수도 있고 직접 next() 함수를 호출하여 평가도 가능하다. L.filter L…","html":"<p>연속된 제너레이터의 계산 순서를 알아보기 전에 map 함수와 filter 함수도 제너레이터를 이용하여 구현해보자.</p>\n<h1 id=\"lmap\"><a href=\"#lmap\" aria-label=\"lmap permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L.map</h1>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">L</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">map</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> a <span class=\"token keyword\">of</span> iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기존 map함수와 다른 점은 </p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> mapList <span class=\"token operator\">=</span> <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위와 같이 이터레이터를 생성한 것 만으로는 내가 원하는 값을 구할 수 없고 next() 함수를 호출 한 만큼의 값만 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>mapList<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {value : 11, done : false}</span></code></pre></div>\n<p>따라서 array를 직접 생성하지 않기 때문에 내가 원하는 대로 평가가 가능하다</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>mapList<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1 2 3 </span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>mapList<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [1, 2, 3]</span></code></pre></div>\n<p>스프레드 연산자로 next() 함수를 호출하여 평가할수도 있고</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>mapList<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [11]</span></code></pre></div>\n<p>직접 next() 함수를 호출하여 평가도 가능하다.</p>\n<h1 id=\"lfilter\"><a href=\"#lfilter\" aria-label=\"lfilter permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L.filter</h1>\n<p>L.map과 비슷한 구현 코드를 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">filter</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> a <span class=\"token keyword\">of</span> iter<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">yield</span> a\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> it <span class=\"token operator\">=</span> <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span> <span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a<span class=\"token operator\">%</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value : 1, done : false }</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value : 3, done : false }</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value : undefined, done : true }</span></code></pre></div>\n<h1 id=\"엄격한-계산-순서-vs-느긋한-계산-순서-중첩사용\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EA%B3%84%EC%82%B0-%EC%88%9C%EC%84%9C-vs-%EB%8A%90%EA%B8%8B%ED%95%9C-%EA%B3%84%EC%82%B0-%EC%88%9C%EC%84%9C-%EC%A4%91%EC%B2%A9%EC%82%AC%EC%9A%A9\" aria-label=\"엄격한 계산 순서 vs 느긋한 계산 순서 중첩사용 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엄격한 계산 순서 vs 느긋한 계산 순서 (중첩사용)</h1>\n<ul>\n<li>기존에 사용했던 함수들을 이용</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">go</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a<span class=\"token operator\">+</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  log\n<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [11, 13]</span></code></pre></div>\n<ul>\n<li>느슨한 함수들을 이용</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">go</span><span class=\"token punctuation\">(</span>\n\t<span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a<span class=\"token operator\">+</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  log\n<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [11, 13]</span></code></pre></div>\n<p><strong>두 가지 방식의 코드의 결과는 같지만 두 코드가 동작하는 방식, 순서가 다르고 리턴되는 값, 함수들이 평가되는 순서도 다르다.</strong></p>\n<blockquote>\n<h2 id=\"엄격한-계산의-순서\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EA%B3%84%EC%82%B0%EC%9D%98-%EC%88%9C%EC%84%9C\" aria-label=\"엄격한 계산의 순서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엄격한 계산의 순서</h2>\n</blockquote>\n<p>먼저 엄격한 방식부터 살펴보면 range(10) 함수부터 실행되게 된다. 크롬 개발자 도구의 break point를 이용하여 함수에서 변수들이 어떻게 평가되는지 살펴보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70369536-81ffb480-18fe-11ea-8d53-a7bba032ed70.png\" alt=\"image\"></p>\n<p>range(10)을 하였을 때 함수가 실행되고 지역변수 l 값이 10으로 평가된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70369562-f0447700-18fe-11ea-8be8-f82e115828eb.png\" alt=\"image\"></p>\n<p>그 뒤 while 문에 들어가면서 i 값이 증가되고 res 배열에 하나씩 담고 l 값와 i 값이 같아질 때 함수를 종료한다.</p>\n<p>다음으로 실행되는 map 함수를 break point로 확인 하기전에 이터러블을 인자로 받는 함수들의 내부 코드를 좀더 세세하게 확인할 수 있게 수정해보자. ( 명령형 코드로 전환 )</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">f<span class=\"token punctuation\">,</span> iter</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> a <span class=\"token keyword\">of</span> iter<span class=\"token punctuation\">)</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>기존의 코드를!</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">f<span class=\"token punctuation\">,</span> iter</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  iter <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 이터러블 => 이터레이터</span>\n  <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> cur <span class=\"token comment\">// 현재 처리되는 값을 담을 곳</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>value\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">...</span> 나머지 함수들도<span class=\"token operator\">!</span></code></pre></div>\n<p>위와 같이 명령형 코드로 전환하여 개발자 도구로 확인해 보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70369838-9b0a6480-1902-11ea-8be5-6bb182cf75f3.png\" alt=\"image\"></p>\n<p>range(10) 함수가 평가된 값이 map 함수의 이터러블 인자로 온다. ( go 함수 내부에서 전달 ) 인자로 전달 받은 배열은 </p>\n<p>6번 줄을 거쳐</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70369858-dad14c00-1902-11ea-9fca-0177071d1536.png\" alt=\"image\"></p>\n<p>위와 같이 Array Iterator {} 로 변환 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70369894-3d2a4c80-1903-11ea-8f12-f8c7b61b4123.png\" alt=\"image\"></p>\n<p>그 뒤에 while문 안에 들어가여 cur 값에 next() 함수의 결과값을 담고 done이 true가 나오기 전까지 a 값에 next() 함수의 value값을 담으면서 res에 push 하는 구조이다.</p>\n<p>filter, take도 map 과 같은 방식으로 동작한다. 결론은 <strong>전체적인 함수의 흐름이 순차적으로 실행 된다.( 가로 방향 )</strong></p>\n<blockquote>\n<h2 id=\"느긋한-계산의-순서\"><a href=\"#%EB%8A%90%EA%B8%8B%ED%95%9C-%EA%B3%84%EC%82%B0%EC%9D%98-%EC%88%9C%EC%84%9C\" aria-label=\"느긋한 계산의 순서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느긋한 계산의 순서</h2>\n</blockquote>\n<p>우선 Lazy 함수들도 직관적인 계산 확인이 가능하게 명령형 코드로 수정을 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span>map <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  iter <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> cur\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">yield</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span>filter <span class=\"token operator\">=</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> iter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  iter <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> cur\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>value\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">yield</span> a\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위와 같이 수정을 한 뒤 엄격한 계산과 같은 결과를 출력하는 코드를 실행 시키자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">go</span><span class=\"token punctuation\">(</span>\n\t<span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">L</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  log\n<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [11, 13]</span></code></pre></div>\n<p><strong>엄격한 방식의 계산의 순서</strong>는</p>\n<ul>\n<li>range(10) => L.map(a => a+10) => L.filter( a => a % 2) => take(2) => log</li>\n</ul>\n<p>처럼 <strong>가로방향으로 순차적으로 이전 함수의 결과가 다음 함수에 전달되는 형식으로 실행</strong> 되었다.</p>\n<p>그럼 느긋한 계산 방식은 어떤점이 다를까? 결론부터 말하면 느긋한 계산방식은 위 코드를 실행 시켰을 때 <strong>가장 먼저 실행되는 함수는 take 함수이다.</strong> 그 이유를 살펴보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/70371878-da917a80-191b-11ea-84e9-a33d6b7ee0a4.png\" alt=\"image\"></p>\n<p>break point를 찍었을 때 가장 먼저 break가 걸린 구간을 확인한 결과이다. 보이는 것과 같이 take 함수에서 break 포인트가 걸렸다.</p>\n<p>이유는 <strong>L.range, L.map, L.filter 함수는 제너레이터이다. 제너레이터는 함수 자체를 실행 했을때는 내부 코드가 동작하지 않고 제너레이터에 의해 생성된 이터레이터가 next() 함수를 호출 했을 때 제너레이터 내부의 코드가 동작한다.</strong></p>\n<p>따라서 L.range(10) 함수를 실행 시켰을 때 함수 내부의 코드가 동작하지 않고 일단 이터레이터를 리턴한다. 이 이터레이터는 L.map 함수의 파라미터로 전달 된다. 하지만 L.map 함수 역시 제너레이터기 때문에 L.map 함수가 리턴하는 이터레이터의 next() 함수가 호출 될 때 까지 함수 내부의 코드가 동작하지 않고 바로 이터레이터를 리턴한다. 이 이터레이터는 filter 함수의 파타미터로 전달 되는데 filter 함수 역시 제너레이터 이기 때문에 filter 함수 역시 이터레이터를 리턴하고 take 함수가 이것을 받는다.</p>\n<p>정리해보면</p>\n<ul>\n<li>range(10) 실행 => range 함수가 이터레이터 리턴 => map 함수가 이터레이터 리턴 => filter 함수가 이터레이터 리턴 => take 함수 실행</li>\n</ul>\n<p>그 다음 동작을 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//take 함수</span>\niter <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> cur\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// iter.next() => filter 함수 내부코드 동작</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>take 함수는 filter 함수의 이터레이터를 받았기 때문에  iter.next() 함수를 호출 하였을 때 filter 함수의 내부코드가 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//filter 함수</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// iter.next() => Map 함수 내부코드 동작</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>filter 함수의 내부코드가 동작 하는데 이 함수가 받은 이터레이터는 Map 함수의 이터레이터이다. 따라서 filter 함수 내부의 iter.next()는 Map 함수 내부의 코드를 동작 시킨다. 같은 방식으로 Map 함수의 인자 이터레이터가 next() 함수를 호출하면 range() 함수내부 코드가 동작한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Map 함수</span>\n<span class=\"token keyword\">let</span> cur <span class=\"token comment\">// range 함수에서 yield 한 { value : 0, done : false} 값 저장</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>value <span class=\"token comment\">// 0</span>\n  <span class=\"token keyword\">yield</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>range 함수에서는 인자로 받은 이터레이터가 없기 때문에 내부 코드가 동작하면 Map 함수 내부의 cur값에 자신이 yield 한 { value : 0, done : false } 값이 저장된다. </p>\n<p>map 함수는 cur.value 값이 저장된 a 를 자신이 받은 함수로 평가하여 yield 하고 이를 filter 함수 내부의 cur 값에 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// filter 함수</span>\n<span class=\"token keyword\">let</span> cur <span class=\"token comment\">// map 함수에서 yield 한 { value : 10, done : false } 값 저장</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>value <span class=\"token comment\">// 10</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">yield</span> a\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 평가된 a는 if 조건문을 만족 시키지 않기 때문에 ( 10 => 10 % 2 ) filter 함수는 take 함수로 값을 yield 하지 않고 다시 while 문을 돌게 된다. 그럼 iter.next() 함수에 의해 다시 map 함수의 제너레이터 내부 코드 실행 시키고 이는 range 함수의 내부코드를 실행시켜 range함수는 { value : 1, done : false }를 yield 한다. 이 값을 map 함수에서는 { value : 11, done : false } 로 yield 하고 filter 함수에서 f(a) 조건문을 총족시켜 take 함수로 값을 yield 한다.</p>\n<p>이것이 느긋한 방식으로 코딩된 함수들의 계산 순서이다.</p>\n<p>결론을 지으면 <strong>엄격한 계산은 각 함수에서 리스트를 생성하여 다음 함수로 리스트를 전달하는 계산 순서를 갖는다면 ( 가로방식 ), 느긋한 계산 방식은 값 하나씩 yield 하는 방식 즉,</strong></p>\n<ul>\n<li>1 => 11 => 11</li>\n<li>3 = > 13 => 13</li>\n</ul>\n<p><strong>최종값 [11, 13] 라는 계산 순서를 갖는다.</strong></p>","frontmatter":{"title":"(중요) 함수형 프로그래밍(연속된 제너레이터 계산 순서)(1)","date":"December 07, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/javascript/함수형-프로그래밍(엄격vs느긋)-(1)/","previous":{"fields":{"slug":"/javascript/함수형-프로그래밍(take,-지연성-평가)/"},"frontmatter":{"title":"함수형 프로그래밍(take, 지연성 평가)","category":"javascript"}},"next":null}}}