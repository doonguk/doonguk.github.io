{"componentChunkName":"component---src-templates-blog-post-js","path":"/cs/브라우저-렌더링-과정/","result":{"data":{"site":{"siteMetadata":{"title":"Study Log","author":"[HongDongUk]","siteUrl":"https://donguk.netlify.com","comment":{"disqusShortName":"","utterances":"doonguk/doonguk.github.io"},"sponsor":{"buyMeACoffeeId":"doonguk"}}},"markdownRemark":{"id":"457efffe-c5fc-53fc-a830-87dc0852d953","excerpt":"1. 렌더링 엔진 대부분의 브라우저는 렌더링을 수행하는 렌더링 엔진을 가지고 있다. 다만 모든 브라우저가 같은 렌더링 엔진을 사용하지는 않는다. 사파리의 경우 대부분이 알고있는  엔진을 사용한다. 각 브라우저별로 테스트를 수행하여 여러 브라우저의 호환성에 문제가 없는지 검사해야한다. 1.5. DOM 과 BOM 렌더링 과정을 알기전에 DOM과 BOM을 알고 지나가자. 우선 BOM(Brower Object Model…","html":"<h3 id=\"1-렌더링-엔진\"><a href=\"#1-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84\" aria-label=\"1 렌더링 엔진 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 렌더링 엔진</h3>\n<ol>\n<li>대부분의 브라우저는 렌더링을 수행하는 <strong>렌더링 엔진</strong>을 가지고 있다.</li>\n<li>다만 모든 브라우저가 같은 렌더링 엔진을 사용하지는 않는다. 사파리의 경우 대부분이 알고있는 <code class=\"language-text\">webkit</code> 엔진을 사용한다.</li>\n<li>각 브라우저별로 테스트를 수행하여 여러 브라우저의 호환성에 문제가 없는지 검사해야한다.</li>\n</ol>\n<h3 id=\"15-dom-과-bom\"><a href=\"#15-dom-%EA%B3%BC-bom\" aria-label=\"15 dom 과 bom permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5. DOM 과 BOM</h3>\n<p>렌더링 과정을 알기전에 DOM과 BOM을 알고 지나가자.</p>\n<p>우선 BOM(Brower Object Model)은 <strong>브라우저의 창이나 프레임을 프로그래밍적으로 제어할 수 있게 해주는 객체모델 이다.</strong> 이를 통해서 브라우저의 새 창을 열거나 다른 문서로 이동하는 등의 기능을 실행시킬 수 있다. 전역 객체로 <code class=\"language-text\">window</code>가 있으며 하위 객체들로 <code class=\"language-text\">location</code>, <code class=\"language-text\">navigator</code>, <code class=\"language-text\">history</code>, <code class=\"language-text\">screen</code>, <code class=\"language-text\">document</code>가 포함되어 있다.</p>\n<p>DOM(Document Object Model)은 <strong>웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체모델이다(HTML, XML 문서의 프로그래밍 interface ).</strong> 최상위 인터페이스로 Node가 있다.</p>\n<p>내가 작성한 HTML 코드가 DOM일까 ? <strong>아니다</strong> 브라우저에 파싱되면 DOM이 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/39187116/83643381-eae49280-a5ea-11ea-9dc7-3415501ca956.png\" alt=\"image\"></p>\n<p>예시로</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>제목<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>클래스<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token comment\">&lt;!-- 주석 --></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://naver.com<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>네이버<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>위와 같은 코드가 있을 때</p>\n<p><img src=\"https://github.com/baeharam/Must-Know-About-Frontend/blob/master/images/frontend/dom2.png?raw=true\" alt=\"dom2.png\"></p>\n<p>Live DOM viewer를 사용하면 위와같은 DOM트리가 완성된다. 보면  텍스트 노드와 주석 노드까지 포함된걸 볼 수 있다.( 주석 제거 잘 해야겠네..) 이런 DOM을 다루기 위해선 <code class=\"language-text\">document.querySelector</code>와 같은 DOM API를 사용하면 된다.</p>\n<h3 id=\"2-렌더링-과정\"><a href=\"#2-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95\" aria-label=\"2 렌더링 과정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 렌더링 과정</h3>\n<h4 id=\"dom-document-object-model-cssom-css-object-model-생성\"><a href=\"#dom-document-object-model-cssom-css-object-model-%EC%83%9D%EC%84%B1\" aria-label=\"dom document object model cssom css object model 생성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM (Document Object Model), CSSOM (CSS Object Model) 생성</h4>\n<p>첫번째 단계는 서버로부터 받은 HTML, CSS를 다운로드 받는다. 받은 HTML, CSS 파일은 단순한 텍스트이므로 연산과 관리가 유리한 Object Model을 만든다. 이 과정에서 HTML, CSS 파일은 각각 <code class=\"language-text\">DOM Tree</code>와 <code class=\"language-text\">CSSOM</code>으로 만들어진다.</p>\n<p>추가적으로 렌더링 엔진은 더 나은 UX(사용자 경험) 을 위해 모든 HTML 파싱이 끝나기 전에 사용자에게 보여줄 수 있는 일부 내용들을 미리 출력한다.</p>\n<h4 id=\"render-tree-생성\"><a href=\"#render-tree-%EC%83%9D%EC%84%B1\" aria-label=\"render tree 생성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Render Tree 생성</h4>\n<p>DOM Tree와 CSS Tree를 이용하여 <code class=\"language-text\">Render Tree</code>를 생성한다. DOM Tree는 <strong>순수한 요소들의 구조와 텍스트</strong>만 존재한다. 하지만 Render Tree를 만드는 과정에서 각 요소들의 스타일이 계산되고, 이 과정에서 다른 요소들의 스타일 속성들을 참조한다. 따라서 Render Tree는  <strong>스타일 정보가 설정</strong>되어 있고 <strong>실제 화면에 표현되는 노드들로만 구성</strong>된다.</p>\n<p>여기서 실제 화면에 표현되지 <strong>않는</strong> 노드의 예시는 <code class=\"language-text\">display: none</code> 속성이 설정된 노드이다. 반면에 <code class=\"language-text\">visibility: invisible</code>은 화면에 표시되지 않지만 공간을 차지하기 때문에 Render Tree에 포함된다.</p>\n<p>추가적으로, Webkit ( 크롬 브라우저 엔진 ) 에서는 노드의 스타일을 처리하는 과정을 <code class=\"language-text\">attachment</code> 라고 한다. DOM Tree의 모든 노드들은 <code class=\"language-text\">attach</code>라는 메소드가 있고, 이 메소드는 노드의 스타일 정보를 계산하여 객체형태로 반환한다. 이 과정은 <strong>동기적</strong>으로 일어난다. </p>\n<blockquote>\n<p>동기적으로 처리되니 JS로 DOM 요소의 속성을 변경할 때 한번에 처리해주면 Reflow 발생 횟수가 줄어들겠네..</p>\n</blockquote>\n<h4 id=\"layout\"><a href=\"#layout\" aria-label=\"layout permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layout</h4>\n<p>Render Tree 노드들이 가지고 있는 스타일 정보와 속성을 이용해서 <strong>브라우저에 어느위치에 어느크기로 출력될지 계산하는 단계</strong>이다. 이 과정에서 <code class=\"language-text\">%, vh, vw</code> 와 같은 상대적인 위치, 크기 속성들은 실제 화면에 그려지는 pixel 단위로 변환된다.</p>\n<blockquote>\n<p>뷰포트(Viewport)란? 그래픽이 표시되는 브라우저의 영역, 크기를 말한다.</p>\n</blockquote>\n<h4 id=\"paint\"><a href=\"#paint\" aria-label=\"paint permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Paint</h4>\n<p>Layout 단계에서 계산이 완료되면 요소들을 실제 화면에 그리게 된다. 이때 텍스트, 색, 이미지, 그림자 효과등이 모두 처리되어 그려진다.  ( <code class=\"language-text\">paint()</code> 메소드 호출 )</p>\n<br/>\n<h3 id=\"3-reflow와-refaint\"><a href=\"#3-reflow%EC%99%80-refaint\" aria-label=\"3 reflow와 refaint permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Reflow와 Refaint</h3>\n<h4 id=\"reflow-render-tree-생성--layout\"><a href=\"#reflow-render-tree-%EC%83%9D%EC%84%B1--layout\" aria-label=\"reflow render tree 생성  layout permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflow (Render Tree 생성 ~ Layout)</h4>\n<p>위에서 말한 과정을 거친 뒤에 페이지가 그려진다고 해서 렌더링 과정이 다 끝난것이 아니다. 어떠한 액션이나 이벤트에 따라 HTML의 요소의 크기나 위치등 레이아웃 수치를 수정하면 그에 영향을 받는 자식 노드나 부모 노드를 포함하여 Layout 과정을 다시 수행하게 된다. 이렇게 되면 <strong>Render Tree와 각 요소들의 크기와 위치를 다시 계산하게 된다. 이러한 과정을 Reflow</strong> 라고 한다.</p>\n<p>대표적인 예시는</p>\n<ul>\n<li>페이지 초기 렌더링 시 ( 최소 Layout 과정 )</li>\n<li>윈도우 리사이징 시 ( Viewport 크기 변경시)</li>\n<li>노드 추가 또는 제거</li>\n<li>요소의 위치, 크기 변경 (left, top, margin, padding, border, width, height 등)</li>\n<li>폰트 변경 과(텍스트 내용) 이미지 크기 변경(크기가 다른 이미지로 교체)</li>\n</ul>\n<h4 id=\"repaint-paint\"><a href=\"#repaint-paint\" aria-label=\"repaint paint permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Repaint (paint)</h4>\n<p>Reflow만 수행되면 실제 화면에 반영되지 않는다. 위에서 언급된 렌더링 과정과 같이 Render Tree를 다시 화면에 그려주는 과정이 필요하다. 결국 Paint 단계가 다시 수행되는 것이며 이를 Repaint 라고 한다.</p>\n<p><em>무조건 Reflow가 일어나야 Refaint가 일어나는게 아니다. 예를들어 background-color 변경 같은 레이아웃에 영향을 주지 않는 스타일 속성이 변경되었을 때는 Reflow를 수행할 필요가 없기 때문에 Repaint만 수행하게 된다.</em></p>\n<br/>\n<h3 id=\"4-why-virtual-dom\"><a href=\"#4-why-virtual-dom\" aria-label=\"4 why virtual dom permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Why Virtual DOM?</h3>\n<p>일반적으로 dom에 접근하여 여러번의 속성 변화, 여러번의 스타일 변화를 수행하면 그에따라 Render Tree를 만들고 ( Reflow ) 다시 그리는 ( Refaint ) 작업을 여러번하게 된다. 하지만 Virtual DOM은 이렇게 변화가 일어나는 사항들을 한번에 묶어서 실제 DOM에 전달하게 된다. 따라서 실제 연산은 딱 <strong>한번</strong>만 수행하게 된다. 이를 통해 여러번 Reflow, Refaint를 수행하며 연산이 반복적으로 일어나는 부분이 줄어들어 성능이 개선된다.</p>\n<br/>\n<h3 id=\"5-reference\"><a href=\"#5-reference\" aria-label=\"5 reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Reference</h3>\n<ol>\n<li><a href=\"https://velog.io/@godori/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">https://velog.io/@godori/DOM%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a></li>\n<li><a href=\"https://boxfoxs.tistory.com/408\">https://boxfoxs.tistory.com/408</a></li>\n<li><a href=\"https://velopert.com/3236\">https://velopert.com/3236</a></li>\n<li><a href=\"https://falsy.me/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9D%B4%ED%95%B4-1-reflow-repaint%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B4%85%EB%8B%88%EB%8B%A4/\">https://falsy.me/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9D%B4%ED%95%B4-1-reflow-repaint%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B4%85%EB%8B%88%EB%8B%A4/</a></li>\n<li><a href=\"https://github.com/baeharam/Must-Know-About-Frontend/blob/master/Notes/frontend/bom-dom.md\">https://github.com/baeharam/Must-Know-About-Frontend/blob/master/Notes/frontend/bom-dom.md</a></li>\n</ol>\n<h3 id=\"\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>","frontmatter":{"title":"브라우저 렌더링 과정","date":"May 27, 2020"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/cs/브라우저-렌더링-과정/","previous":{"fields":{"slug":"/leetcode/20200525-리트코드/"},"frontmatter":{"title":"20200525 리트코드","category":"leetcode"}},"next":{"fields":{"slug":"/leetcode/20200529-리트코드/"},"frontmatter":{"title":"20200529 리트코드","category":"leetcode"}}}}}